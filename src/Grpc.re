/* AUTO-GENERATED BY bs-grpc --- EDIT AT YOUR OWN PERIL */

  exception BsGrpcDecoderError(string);
  exception ImpossibleError(string);
  let (<<) = (f, g, x) => f(g(x));
  /** an opaque type for error objects from grpc-node when the client invokes
   an RPC */
  type grpcClientRpcInvokeError;
  /* simply wraps grpcClientRpcInvokeError when an exception is needed */
  exception GrpcClientRpcInvokeError(grpcClientRpcInvokeError);

  /* "channel credentials" seem to be needed for creating a client */
  type channelCredentials;
  type callCredentials;
  type serverCredentials;

  /* protobufjs uses ByteBuffer abstraction over Node Buffer */
  type byteBuffer;
  [@bs.send] external bufferOfByteBuffer : byteBuffer => Node.buffer = "finish";

  /* flatMap an array of Futures */
  let futureFlatMapArray =
      (f: 'a => Future.t('b), maxConcurrent, xs: array('a)) =>
    Future.(
      make(resolve => {
        let result: array(option('b)) =
          xs |. Array.length |. Belt.Array.make(None);
        let xlen = Array.length(xs);
        let numJobs = ref(0);
        let cursor = ref(0);
        let rec pump = () => {
          if (cursor^ == xlen) {
            if (numJobs^ == 0) {
              result |> Array.map(Belt.Option.getExn) |. resolve;
            };
          } else {
            let i = cursor^;
            cursor := cursor^ + 1;
            numJobs := numJobs^ + 1;
            xs[i]
            |. f
            |. get(x => {
                 result[i] = Some(x);
                 numJobs := numJobs^ - 1;
                 pump();
               });
          };
          ();
        };
        for (_ in 1 to min(maxConcurrent, xlen)) {
          pump();
        };
        ();
      })
    );

  /** return Some(x) for the first x of an array for which predictate f
   returns true, starting from element at index n, or None if no such element is
   found */
  let rec arrayFirst = (f, n, a) =>
    n < Array.length(a) ? f(a[n]) ? Some(a[n]) : arrayFirst(f, n + 1, a) : None;

  /* utility eunction; TODO is there a stdlib answer? */
  let optCall = (x, ~f) =>
    switch (x) {
    | None => ()
    | Some(x) => f(x)
    };

  /** Convenience function for simplifying server replies */
  let reply = (callback, x) =>
    callback(.
      Js.Nullable.null,
      x,
      Js.Nullable.undefined,
      Js.Nullable.undefined,
    );

  module Validation = {
    exception MissingFieldError;
    exception StringTooLongError;
    exception StringTooShortError;
    exception ArrayTooShortError;
    exception FractionalNumberError;
    exception WrongStringError;
    exception UnimplementedError;
    exception WrongNumberError;
    exception NumberOutOfRangeError;
    exception NumberNotPositiveError;
    exception RegexMatchError;
    exception TransFieldError(string);
    exception EmptyOneof(string);

    /* invokes user-supplied function to perform multi-field
     * validation, if such a function is supplied
     * TODO move to Validation module */
    let transFieldError = errMsg => Belt.Result.Error(
      TransFieldError(errMsg)
    );

    type field('a) =
      | Field(string, Future.t(Belt.Result.t(option('a), exn)));
    let fieldMap = (f, Field(fieldName, x)) => Field(fieldName, f(x));
    let fieldGet = (Field(_, x)) => x;
    let futureMap = (a, b) => Future.map(b, a);
    let futureFlatMap = (a, b) => Future.map(b, a);
    let resultMap = (a, b) => Belt.Result.map(b, a);
    let resultFlatMap = (a, b) => Belt.Result.flatMap(b, a);
    let optionMap = (a, b) => Belt.Option.map(b, a);
    let optionFlatMap = (a, b) => Belt.Option.flatMap(b, a);
    let resultOptionFlatMap = f => fun
    | Belt.Result.Ok(Some(x)) => f(x)
    | x => x
    ;
    let okSome = x => Belt.Result.Ok(Some(x));
    let error = e => Belt.Result.Error(e);

    let value = (fieldName, x) =>
      Field(fieldName, Future.value(Belt.Result.Ok(x)));
    let fieldValidatorOfMessageValidator = (f, Field(name, future)) =>
      future
      |. Future.flatMapOk(x =>
           switch (x) {
           | None => None |. Belt.Result.Ok |. Future.value
           | Some(thing) =>
             f(thing)
             |. Future.mapError(str => str |. TransFieldError)
             |. Future.mapOk(x => Some(x))
           }
         )
      |. (fresult => Field(name, fresult));


    let numberRange = (lo, hi) =>
      fieldMap @@ futureMap @@ resultOptionFlatMap @@ (x => 
          lo <= x && x <= hi ? okSome(x) : error(NumberOutOfRangeError)
      );
    let maxNumber = numberRange(Js.Int.min);
    let minNumber = n => numberRange(n, Js.Int.max);
    /* TODO can isEqualNumber and isEqualString be merged? */
    let isEqualNumber = n =>
      fieldMap @@ futureMap @@ resultOptionFlatMap @@ (x =>
          x == n ?  okSome(x) : error(WrongNumberError)
      );
    let isEqualString = s =>
      fieldMap @@ futureMap @@ resultOptionFlatMap @@ (x =>
                                     x == s ? okSome(x) : error(WrongStringError)
      );
    let isInt =
      fieldMap @@ futureMap @@ resultOptionFlatMap @@ (x =>
          Js.Math.trunc(x) == x ?
            okSome(x) : error(FractionalNumberError)
      );
    /* TODO can notEqualNumber and notEqualString be merged? */
    let notEqualNumber = n =>
      fieldMap @@ futureMap @@ resultOptionFlatMap @@ (x =>
          x != n ?
            okSome(x) : error(WrongNumberError)
      );
    let notEqualString = s =>
      fieldMap @@ futureMap @@ resultOptionFlatMap @@ (x =>
          s == x ?
            okSome(x) : error(WrongStringError)
      );
    /* TODO is this in the stdlib? */
    [@bs.new] external newRegExp : string => Js.Re.t = "RegExp";
    let matchRegex = re => {
      let re = newRegExp(re);
      fieldMap @@ futureMap @@ resultOptionFlatMap @@ (x =>
        x |. Js.Re.test(re) ? okSome(x) : error(RegexMatchError)
      );
    };
    let required = x =>
      x
      |> fieldMap @@
      futureMap(
        fun
        | Belt.Result.Ok(None) => error(MissingFieldError)
        | x => x,
      );
    let maxStrLen = len =>
      fieldMap @@ futureMap @@ resultOptionFlatMap @@ (x =>
          x |. String.length <= len ?
            okSome(x) : error(StringTooLongError)
      );
    let minStrLen = len =>
      fieldMap @@ futureMap @@ resultOptionFlatMap @@ (x =>
          x |. String.length >= len ?
            okSome(x) : error(StringTooShortError)
      );
    let nonEmptyString = minStrLen(1);
    let trimString =
      fieldMap @@ futureMap @@ resultMap @@ optionMap @@ Js.String.trim;

    /* TODO implement in terms of previous validators */
    let positive = minNumber(1);
    /* Is US Employer Identification Numebr? */
    /* let isUSEIN */
    let repeated:
    (field('a) => field('a), field(array('a))) => field(array('a)) =
    (f, Field(fieldName, future)) => {
      let foo = x =>
        switch (x) {
        | None => None |. Belt.Result.Ok |. Future.value
        | Some(thing) =>
          let bar =
            thing
            |> futureFlatMapArray(
                 x =>
                   Field(fieldName, Future.value(Belt.Result.Ok(Some(x))))
                   |> f
                   |> fieldGet
                   |. Future.mapOk(Belt.Option.getExn),
                 0x7fffffff,
               );

          bar
          |. Future.map(
               (x: array(Belt.Result.t('a, exn))) => {
               let firstError = arrayFirst(Belt.Result.isError, 0, x);
               switch (firstError) {
               | Some(Belt.Result.Error(x)) => Belt.Result.Error(x)
               | None => Belt.Result.Ok(Array.map(Belt.Result.getExn, x))
               | Some(Belt.Result.Ok(_)) =>
                 raise(ImpossibleError("found unfound element"))
               };
             })
          |. Future.mapOk(x => Some(x));
        };
      let future = Future.flatMapOk(future, foo);
      Field(fieldName, future);
    };

    let minItemCount = (len, x: field(array('a))) =>
      x
      |> fieldMap @@
      futureMap(
        fun
        | Belt.Result.Ok(Some(x)) =>
          x |. Array.length < len ?
            Belt.Result.Error(ArrayTooShortError) : Belt.Result.Ok(Some(x))
        | x => x,
      );
    let maxItemCount = (len, x: field(array('a))) =>
      x
      |> fieldMap @@
      futureMap(
        fun
        | Belt.Result.Ok(Some(x)) =>
          x |. Array.length > len ?
            Belt.Result.Error(ArrayTooShortError) : Belt.Result.Ok(Some(x))
        | x => x,
      );

    let err2msg =
      fun
      | MissingFieldError => "required field missing"
      | StringTooLongError => "string value too long"
      | StringTooShortError => "string value too short"
      | NumberNotPositiveError => "number value non-positive"
      | ArrayTooShortError => "not enough items"
      | FractionalNumberError => "number is fractional"
      | WrongStringError => "string mismatch"
      | UnimplementedError => "unimplemented validation"
      | WrongNumberError => "wrong number"
      | NumberOutOfRangeError => "number ouf ot range"
      | RegexMatchError => "string pattern mismatch"
      | TransFieldError(s) => "involving multiple fields: " ++ s
      | _ => "unknown error";

    let fold = (Field(fieldName, Future.Future(get)), happy, sad) =>
      get(x =>
        switch (x) {
        | Belt.Result.Ok(x) => happy(x)
        | Belt.Result.Error(err) => err |> err2msg |> sad(fieldName)
        }
      );
  };

  /** a type that cannot be instantiated */
  type uninstantiable;
  /** a type to only hold values like Js.Nullable.null and
   * Js.Nullable.undefined */
  type justNull = Js.Nullable.t(uninstantiable);
  type grpcLoadResult;

  [@bs.module "bs-grpc"] external grpcLoadProto : string => grpcLoadResult = "load";

  /* Represents a grpc.Server object */
  type server;

  /* A node.js bufffer TODO see if there is a more standard type somewhere
   * for this. We treat it as opaque, though, so it's probably okay.
   */
  type buffer;

  /* This type is part of the type of grpc.ServerCredentials.createSsl() */
  module ServerKeyAndCert = {
    [@bs.deriving abstract]
    type t = {
      [@bs.as "private_key"] privateKey: buffer,
      [@bs.as "cert_chain"] certChain: buffer,
    };
  };
/* fileName = "undefined" */
/* moduleName = "*root*" */
module Config = {
/* fileName = "common.proto" */
/* moduleName = "Com.Paletten.Werk.Proto.Common.Config" */

        type grpcProtoHandle;
        [@bs.get] external getProtoHandle : grpcLoadResult => grpcProtoHandle = "com.paletten.werk.proto.common.config";
        let myProtoHandle = grpcLoadProto("common.proto") |> getProtoHandle;
      module WholeConfiguration = {
/* fileName = "undefined" */
/* moduleName = "Com.Paletten.Werk.Proto.Common.Config.WholeConfiguration" */
/* Message module */
          [@bs.deriving abstract]
          type t =
        {
[@bs.optional] building : Paletten.werk.proto.common.config.Building.t,
[@bs.optional] project : Paletten.werk.proto.common.config.Project.t,
[@bs.optional] roof : Paletten.werk.proto.common.config.Roof.t,
[@bs.optional] roofColor : Paletten.werk.proto.common.config.RoofColor.t,
[@bs.optional] elevation : Paletten.werk.proto.common.config.Elevation.t,
[@bs.optional] elevationColor : Paletten.werk.proto.common.config.ElevationColor.t,
[@bs.optional] energyStandard : Paletten.werk.proto.common.config.EnergyStandard.t,
[@bs.optional] finish : Paletten.werk.proto.common.config.Finish.t,
[@bs.optional] finishStyle : Paletten.werk.proto.common.config.FinishStyle.t,
[@bs.optional] wholeConfiguration : Paletten.werk.proto.common.config.WholeConfiguration.t,
[@bs.optional] addition : Paletten.werk.proto.common.config.Addition.t,
[@bs.optional] userEmail : string,
[@bs.optional] userPhoneNumber : string,
};
/* safe message constructor (may replace t()) */
let make = (
~building=?,
~project=?,
~roof=?,
~roofColor=?,
~elevation=?,
~elevationColor=?,
~energyStandard=?,
~finish=?,
~finishStyle=?,
~wholeConfiguration=?,
~addition=?,
~userEmail=?,
~userPhoneNumber=?,
()) => t(
~building =?building,
~project =?project,
~roof =?roof,
~roofColor =?roofColor,
~elevation =?elevation,
~elevationColor =?elevationColor,
~energyStandard =?energyStandard,
~finish =?finish,
~finishStyle =?finishStyle,
~wholeConfiguration =?wholeConfiguration,
~addition =?addition,
~userEmail =?userEmail,
~userPhoneNumber =?userPhoneNumber,
());

            /* sanitize, validate, normalize */
            let validate = x =>
              Future.make(resolve => {
            let buildingRef = ref(x |. buildingGet);
let projectRef = ref(x |. projectGet);
let roofRef = ref(x |. roofGet);
let roofColorRef = ref(x |. roofColorGet);
let elevationRef = ref(x |. elevationGet);
let elevationColorRef = ref(x |. elevationColorGet);
let energyStandardRef = ref(x |. energyStandardGet);
let finishRef = ref(x |. finishGet);
let finishStyleRef = ref(x |. finishStyleGet);
let wholeConfigurationRef = ref(x |. wholeConfigurationGet);
let additionRef = ref(x |. additionGet);

                let n = ref(11);
                let failed = ref(false);
                /* message is valid; build the normalized message */
                /* TODO makeMessage is probably vestigial at this point
                let makeMessage = () => {
                  Belt.Result.Ok(t(
            ~building=?buildingRef^,
~project=?projectRef^,
~roof=?roofRef^,
~roofColor=?roofColorRef^,
~elevation=?elevationRef^,
~elevationColor=?elevationColorRef^,
~energyStandard=?energyStandardRef^,
~finish=?finishRef^,
~finishStyle=?finishStyleRef^,
~wholeConfiguration=?wholeConfigurationRef^,
~addition=?additionRef^,

                  ()))
                };
                */
                let wholeMessageValidation =
            x => x;
                let fail = (fieldName, errMsg) => {
                  failed := true;
                  resolve(
                    Belt.Result.Error(
                      {j|error validating field $fieldName: $errMsg|j},
                    ),
                  )
                };
                let tick = (field, y) => {
                  if (!failed^) {
                    field := y;
                    n := n^ - 1;
                    if (n^ == 0) {
                      t(
            ~building =? buildingRef^,
~project =? projectRef^,
~roof =? roofRef^,
~roofColor =? roofColorRef^,
~elevation =? elevationRef^,
~elevationColor =? elevationColorRef^,
~energyStandard =? energyStandardRef^,
~finish =? finishRef^,
~finishStyle =? finishStyleRef^,
~wholeConfiguration =? wholeConfigurationRef^,
~addition =? additionRef^,
~userEmail =? x |. userEmailGet,
~userPhoneNumber =? x |. userPhoneNumberGet,

                      ())
                      |> (x=>Some(x))
                      |> Validation.value("WholeConfiguration")
                      |> wholeMessageValidation
                      |> Validation.required
                      |. Validation.fold(opt => resolve(Belt.Result.Ok(Belt.Option.getExn(opt))), fail);
                    }
                  }
                };
                open Validation;
          /* message field validation */
                buildingRef^
                |> value("building")
                |> fieldValidatorOfMessageValidator @@ Paletten.werk.proto.common.config.Building.validate
                |. fold(tick(buildingRef), fail)
                |. ignore;
              /* message field validation */
                projectRef^
                |> value("project")
                |> fieldValidatorOfMessageValidator @@ Paletten.werk.proto.common.config.Project.validate
                |. fold(tick(projectRef), fail)
                |. ignore;
              /* message field validation */
                roofRef^
                |> value("roof")
                |> fieldValidatorOfMessageValidator @@ Paletten.werk.proto.common.config.Roof.validate
                |. fold(tick(roofRef), fail)
                |. ignore;
              /* message field validation */
                roofColorRef^
                |> value("roofColor")
                |> fieldValidatorOfMessageValidator @@ Paletten.werk.proto.common.config.RoofColor.validate
                |. fold(tick(roofColorRef), fail)
                |. ignore;
              /* message field validation */
                elevationRef^
                |> value("elevation")
                |> fieldValidatorOfMessageValidator @@ Paletten.werk.proto.common.config.Elevation.validate
                |. fold(tick(elevationRef), fail)
                |. ignore;
              /* message field validation */
                elevationColorRef^
                |> value("elevationColor")
                |> fieldValidatorOfMessageValidator @@ Paletten.werk.proto.common.config.ElevationColor.validate
                |. fold(tick(elevationColorRef), fail)
                |. ignore;
              /* message field validation */
                energyStandardRef^
                |> value("energyStandard")
                |> fieldValidatorOfMessageValidator @@ Paletten.werk.proto.common.config.EnergyStandard.validate
                |. fold(tick(energyStandardRef), fail)
                |. ignore;
              /* message field validation */
                finishRef^
                |> value("finish")
                |> fieldValidatorOfMessageValidator @@ Paletten.werk.proto.common.config.Finish.validate
                |. fold(tick(finishRef), fail)
                |. ignore;
              /* message field validation */
                finishStyleRef^
                |> value("finishStyle")
                |> fieldValidatorOfMessageValidator @@ Paletten.werk.proto.common.config.FinishStyle.validate
                |. fold(tick(finishStyleRef), fail)
                |. ignore;
              /* message field validation */
                wholeConfigurationRef^
                |> value("wholeConfiguration")
                |> fieldValidatorOfMessageValidator @@ Paletten.werk.proto.common.config.WholeConfiguration.validate
                |. fold(tick(wholeConfigurationRef), fail)
                |. ignore;
              /* message field validation */
                additionRef^
                |> value("addition")
                |> fieldValidatorOfMessageValidator @@ Paletten.werk.proto.common.config.Addition.validate
                |. fold(tick(additionRef), fail)
                |. ignore;
              
            });
          
           type codec;

          [@bs.send] external encode : (codec, t, justNull, justNull) => byteBuffer = "";
          [@bs.send] external decode : (codec, Node.buffer, justNull, justNull) => t = "";

          [@bs.get] external codec : grpcProtoHandle => codec = "WholeConfiguration";

          let codec = myProtoHandle |. codec;

          let encode = x =>
            encode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined)
            |. bufferOfByteBuffer;
          let decode = x =>
            decode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined);
        };
module Building = {
/* fileName = "undefined" */
/* moduleName = "Com.Paletten.Werk.Proto.Common.Config.Building" */
/* Message module */
          [@bs.deriving abstract]
          type t =
        {
[@bs.optional] id : string,
[@bs.optional] photoId : string,
[@bs.optional] priceIncrease : string,
[@bs.optional] name : string,
};
/* safe message constructor (may replace t()) */
let make = (
~id=?,
~photoId=?,
~priceIncrease=?,
~name=?,
()) => t(
~id =?id,
~photoId =?photoId,
~priceIncrease =?priceIncrease,
~name =?name,
());

            /* no validation specified for this message */
            let validate = x => Future.value(Belt.Result.Ok(x));
          
           type codec;

          [@bs.send] external encode : (codec, t, justNull, justNull) => byteBuffer = "";
          [@bs.send] external decode : (codec, Node.buffer, justNull, justNull) => t = "";

          [@bs.get] external codec : grpcProtoHandle => codec = "Building";

          let codec = myProtoHandle |. codec;

          let encode = x =>
            encode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined)
            |. bufferOfByteBuffer;
          let decode = x =>
            decode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined);
        };
module Project = {
/* fileName = "undefined" */
/* moduleName = "Com.Paletten.Werk.Proto.Common.Config.Project" */
/* Message module */
          [@bs.deriving abstract]
          type t =
        {
[@bs.optional] id : string,
[@bs.optional] photoId : string,
[@bs.optional] priceIncrease : string,
[@bs.optional] name : string,
[@bs.optional] title : string,
[@bs.optional] description : string,
[@bs.optional] metrage : int,
[@bs.optional] floor : int,
[@bs.optional] residentialAttic : bool,
[@bs.optional] photos : array(string),
};
/* safe message constructor (may replace t()) */
let make = (
~id=?,
~photoId=?,
~priceIncrease=?,
~name=?,
~title=?,
~description=?,
~metrage=?,
~floor=?,
~residentialAttic=?,
~photos=?,
()) => t(
~id =?id,
~photoId =?photoId,
~priceIncrease =?priceIncrease,
~name =?name,
~title =?title,
~description =?description,
~metrage =?metrage,
~floor =?floor,
~residentialAttic =?residentialAttic,
~photos =?photos,
());

            /* no validation specified for this message */
            let validate = x => Future.value(Belt.Result.Ok(x));
          
           type codec;

          [@bs.send] external encode : (codec, t, justNull, justNull) => byteBuffer = "";
          [@bs.send] external decode : (codec, Node.buffer, justNull, justNull) => t = "";

          [@bs.get] external codec : grpcProtoHandle => codec = "Project";

          let codec = myProtoHandle |. codec;

          let encode = x =>
            encode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined)
            |. bufferOfByteBuffer;
          let decode = x =>
            decode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined);
        };
module Roof = {
/* fileName = "undefined" */
/* moduleName = "Com.Paletten.Werk.Proto.Common.Config.Roof" */
/* Message module */
          [@bs.deriving abstract]
          type t =
        {
[@bs.optional] id : string,
[@bs.optional] photoId : string,
[@bs.optional] priceIncrease : string,
[@bs.optional] name : string,
[@bs.optional] title : string,
[@bs.optional] description : string,
[@bs.optional] photos : array(string),
};
/* safe message constructor (may replace t()) */
let make = (
~id=?,
~photoId=?,
~priceIncrease=?,
~name=?,
~title=?,
~description=?,
~photos=?,
()) => t(
~id =?id,
~photoId =?photoId,
~priceIncrease =?priceIncrease,
~name =?name,
~title =?title,
~description =?description,
~photos =?photos,
());

            /* no validation specified for this message */
            let validate = x => Future.value(Belt.Result.Ok(x));
          
           type codec;

          [@bs.send] external encode : (codec, t, justNull, justNull) => byteBuffer = "";
          [@bs.send] external decode : (codec, Node.buffer, justNull, justNull) => t = "";

          [@bs.get] external codec : grpcProtoHandle => codec = "Roof";

          let codec = myProtoHandle |. codec;

          let encode = x =>
            encode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined)
            |. bufferOfByteBuffer;
          let decode = x =>
            decode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined);
        };
module RoofColor = {
/* fileName = "undefined" */
/* moduleName = "Com.Paletten.Werk.Proto.Common.Config.RoofColor" */
/* Message module */
          [@bs.deriving abstract]
          type t =
        {
[@bs.optional] id : string,
[@bs.optional] photoId : string,
[@bs.optional] priceIncrease : string,
[@bs.optional] name : string,
[@bs.optional] title : string,
[@bs.optional] color : string,
};
/* safe message constructor (may replace t()) */
let make = (
~id=?,
~photoId=?,
~priceIncrease=?,
~name=?,
~title=?,
~color=?,
()) => t(
~id =?id,
~photoId =?photoId,
~priceIncrease =?priceIncrease,
~name =?name,
~title =?title,
~color =?color,
());

            /* no validation specified for this message */
            let validate = x => Future.value(Belt.Result.Ok(x));
          
           type codec;

          [@bs.send] external encode : (codec, t, justNull, justNull) => byteBuffer = "";
          [@bs.send] external decode : (codec, Node.buffer, justNull, justNull) => t = "";

          [@bs.get] external codec : grpcProtoHandle => codec = "RoofColor";

          let codec = myProtoHandle |. codec;

          let encode = x =>
            encode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined)
            |. bufferOfByteBuffer;
          let decode = x =>
            decode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined);
        };
module Elevation = {
/* fileName = "undefined" */
/* moduleName = "Com.Paletten.Werk.Proto.Common.Config.Elevation" */
/* Message module */
          [@bs.deriving abstract]
          type t =
        {
[@bs.optional] id : string,
[@bs.optional] photoId : string,
[@bs.optional] priceIncrease : string,
[@bs.optional] name : string,
[@bs.optional] title : string,
[@bs.optional] description : string,
[@bs.optional] photos : array(string),
};
/* safe message constructor (may replace t()) */
let make = (
~id=?,
~photoId=?,
~priceIncrease=?,
~name=?,
~title=?,
~description=?,
~photos=?,
()) => t(
~id =?id,
~photoId =?photoId,
~priceIncrease =?priceIncrease,
~name =?name,
~title =?title,
~description =?description,
~photos =?photos,
());

            /* no validation specified for this message */
            let validate = x => Future.value(Belt.Result.Ok(x));
          
           type codec;

          [@bs.send] external encode : (codec, t, justNull, justNull) => byteBuffer = "";
          [@bs.send] external decode : (codec, Node.buffer, justNull, justNull) => t = "";

          [@bs.get] external codec : grpcProtoHandle => codec = "Elevation";

          let codec = myProtoHandle |. codec;

          let encode = x =>
            encode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined)
            |. bufferOfByteBuffer;
          let decode = x =>
            decode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined);
        };
module ElevationColor = {
/* fileName = "undefined" */
/* moduleName = "Com.Paletten.Werk.Proto.Common.Config.ElevationColor" */
/* Message module */
          [@bs.deriving abstract]
          type t =
        {
[@bs.optional] id : string,
[@bs.optional] photoId : string,
[@bs.optional] priceIncrease : string,
[@bs.optional] name : string,
[@bs.optional] title : string,
[@bs.optional] color : string,
};
/* safe message constructor (may replace t()) */
let make = (
~id=?,
~photoId=?,
~priceIncrease=?,
~name=?,
~title=?,
~color=?,
()) => t(
~id =?id,
~photoId =?photoId,
~priceIncrease =?priceIncrease,
~name =?name,
~title =?title,
~color =?color,
());

            /* no validation specified for this message */
            let validate = x => Future.value(Belt.Result.Ok(x));
          
           type codec;

          [@bs.send] external encode : (codec, t, justNull, justNull) => byteBuffer = "";
          [@bs.send] external decode : (codec, Node.buffer, justNull, justNull) => t = "";

          [@bs.get] external codec : grpcProtoHandle => codec = "ElevationColor";

          let codec = myProtoHandle |. codec;

          let encode = x =>
            encode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined)
            |. bufferOfByteBuffer;
          let decode = x =>
            decode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined);
        };
module EnergyStandard = {
/* fileName = "undefined" */
/* moduleName = "Com.Paletten.Werk.Proto.Common.Config.EnergyStandard" */
/* Message module */
          [@bs.deriving abstract]
          type t =
        {
[@bs.optional] id : string,
[@bs.optional] photoId : string,
[@bs.optional] priceIncrease : string,
[@bs.optional] name : string,
[@bs.optional] title : string,
[@bs.optional] description : string,
};
/* safe message constructor (may replace t()) */
let make = (
~id=?,
~photoId=?,
~priceIncrease=?,
~name=?,
~title=?,
~description=?,
()) => t(
~id =?id,
~photoId =?photoId,
~priceIncrease =?priceIncrease,
~name =?name,
~title =?title,
~description =?description,
());

            /* no validation specified for this message */
            let validate = x => Future.value(Belt.Result.Ok(x));
          
           type codec;

          [@bs.send] external encode : (codec, t, justNull, justNull) => byteBuffer = "";
          [@bs.send] external decode : (codec, Node.buffer, justNull, justNull) => t = "";

          [@bs.get] external codec : grpcProtoHandle => codec = "EnergyStandard";

          let codec = myProtoHandle |. codec;

          let encode = x =>
            encode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined)
            |. bufferOfByteBuffer;
          let decode = x =>
            decode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined);
        };
module Finish = {
/* fileName = "undefined" */
/* moduleName = "Com.Paletten.Werk.Proto.Common.Config.Finish" */
/* Message module */
          [@bs.deriving abstract]
          type t =
        {
[@bs.optional] id : string,
[@bs.optional] photoId : string,
[@bs.optional] priceIncrease : string,
[@bs.optional] name : string,
[@bs.optional] title : string,
[@bs.optional] description : string,
};
/* safe message constructor (may replace t()) */
let make = (
~id=?,
~photoId=?,
~priceIncrease=?,
~name=?,
~title=?,
~description=?,
()) => t(
~id =?id,
~photoId =?photoId,
~priceIncrease =?priceIncrease,
~name =?name,
~title =?title,
~description =?description,
());

            /* no validation specified for this message */
            let validate = x => Future.value(Belt.Result.Ok(x));
          
           type codec;

          [@bs.send] external encode : (codec, t, justNull, justNull) => byteBuffer = "";
          [@bs.send] external decode : (codec, Node.buffer, justNull, justNull) => t = "";

          [@bs.get] external codec : grpcProtoHandle => codec = "Finish";

          let codec = myProtoHandle |. codec;

          let encode = x =>
            encode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined)
            |. bufferOfByteBuffer;
          let decode = x =>
            decode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined);
        };
module FinishStyle = {
/* fileName = "undefined" */
/* moduleName = "Com.Paletten.Werk.Proto.Common.Config.FinishStyle" */
/* Message module */
          [@bs.deriving abstract]
          type t =
        {
[@bs.optional] id : string,
[@bs.optional] photoId : string,
[@bs.optional] priceIncrease : string,
[@bs.optional] name : string,
[@bs.optional] title : string,
[@bs.optional] description : string,
[@bs.optional] photos : array(string),
};
/* safe message constructor (may replace t()) */
let make = (
~id=?,
~photoId=?,
~priceIncrease=?,
~name=?,
~title=?,
~description=?,
~photos=?,
()) => t(
~id =?id,
~photoId =?photoId,
~priceIncrease =?priceIncrease,
~name =?name,
~title =?title,
~description =?description,
~photos =?photos,
());

            /* no validation specified for this message */
            let validate = x => Future.value(Belt.Result.Ok(x));
          
           type codec;

          [@bs.send] external encode : (codec, t, justNull, justNull) => byteBuffer = "";
          [@bs.send] external decode : (codec, Node.buffer, justNull, justNull) => t = "";

          [@bs.get] external codec : grpcProtoHandle => codec = "FinishStyle";

          let codec = myProtoHandle |. codec;

          let encode = x =>
            encode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined)
            |. bufferOfByteBuffer;
          let decode = x =>
            decode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined);
        };
module Addition = {
/* fileName = "undefined" */
/* moduleName = "Com.Paletten.Werk.Proto.Common.Config.Addition" */
/* Message module */
          [@bs.deriving abstract]
          type t =
        {
[@bs.optional] id : string,
[@bs.optional] photoId : string,
[@bs.optional] priceIncrease : string,
[@bs.optional] name : string,
[@bs.optional] title : string,
[@bs.optional] description : string,
[@bs.optional] photos : array(string),
};
/* safe message constructor (may replace t()) */
let make = (
~id=?,
~photoId=?,
~priceIncrease=?,
~name=?,
~title=?,
~description=?,
~photos=?,
()) => t(
~id =?id,
~photoId =?photoId,
~priceIncrease =?priceIncrease,
~name =?name,
~title =?title,
~description =?description,
~photos =?photos,
());

            /* no validation specified for this message */
            let validate = x => Future.value(Belt.Result.Ok(x));
          
           type codec;

          [@bs.send] external encode : (codec, t, justNull, justNull) => byteBuffer = "";
          [@bs.send] external decode : (codec, Node.buffer, justNull, justNull) => t = "";

          [@bs.get] external codec : grpcProtoHandle => codec = "Addition";

          let codec = myProtoHandle |. codec;

          let encode = x =>
            encode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined)
            |. bufferOfByteBuffer;
          let decode = x =>
            decode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined);
        };
};
module Service = {
/* fileName = "pdf_service.proto" */
/* moduleName = "Com.Paletten.Werk.Proto.Pdf.Service" */

        type grpcProtoHandle;
        [@bs.get] external getProtoHandle : grpcLoadResult => grpcProtoHandle = "com.paletten.werk.proto.pdf.service";
        let myProtoHandle = grpcLoadProto("pdf_service.proto") |> getProtoHandle;
      module PdfRequest = {
/* fileName = "undefined" */
/* moduleName = "Com.Paletten.Werk.Proto.Pdf.Service.PdfRequest" */
/* Message module */
          [@bs.deriving abstract]
          type t =
        {
[@bs.optional] configuration : Paletten.werk.proto.common.config.WholeConfiguration.t,
};
/* safe message constructor (may replace t()) */
let make = (
~configuration=?,
()) => t(
~configuration =?configuration,
());

            /* sanitize, validate, normalize */
            let validate = x =>
              Future.make(resolve => {
            let configurationRef = ref(x |. configurationGet);

                let n = ref(1);
                let failed = ref(false);
                /* message is valid; build the normalized message */
                /* TODO makeMessage is probably vestigial at this point
                let makeMessage = () => {
                  Belt.Result.Ok(t(
            ~configuration=?configurationRef^,

                  ()))
                };
                */
                let wholeMessageValidation =
            x => x;
                let fail = (fieldName, errMsg) => {
                  failed := true;
                  resolve(
                    Belt.Result.Error(
                      {j|error validating field $fieldName: $errMsg|j},
                    ),
                  )
                };
                let tick = (field, y) => {
                  if (!failed^) {
                    field := y;
                    n := n^ - 1;
                    if (n^ == 0) {
                      t(
            ~configuration =? configurationRef^,

                      ())
                      |> (x=>Some(x))
                      |> Validation.value("PdfRequest")
                      |> wholeMessageValidation
                      |> Validation.required
                      |. Validation.fold(opt => resolve(Belt.Result.Ok(Belt.Option.getExn(opt))), fail);
                    }
                  }
                };
                open Validation;
          /* message field validation */
                configurationRef^
                |> value("configuration")
                |> fieldValidatorOfMessageValidator @@ Paletten.werk.proto.common.config.WholeConfiguration.validate
                |. fold(tick(configurationRef), fail)
                |. ignore;
              
            });
          
           type codec;

          [@bs.send] external encode : (codec, t, justNull, justNull) => byteBuffer = "";
          [@bs.send] external decode : (codec, Node.buffer, justNull, justNull) => t = "";

          [@bs.get] external codec : grpcProtoHandle => codec = "PdfRequest";

          let codec = myProtoHandle |. codec;

          let encode = x =>
            encode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined)
            |. bufferOfByteBuffer;
          let decode = x =>
            decode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined);
        };
module PdfResponse = {
/* fileName = "undefined" */
/* moduleName = "Com.Paletten.Werk.Proto.Pdf.Service.PdfResponse" */
/* Message module */
          [@bs.deriving abstract]
          type t =
        {
[@bs.optional] pdfForClient : Node.Buffer.t,
[@bs.optional] pdfForAdmin : Node.Buffer.t,
};
/* safe message constructor (may replace t()) */
let make = (
~pdfForClient=?,
~pdfForAdmin=?,
()) => t(
~pdfForClient =?pdfForClient,
~pdfForAdmin =?pdfForAdmin,
());

            /* no validation specified for this message */
            let validate = x => Future.value(Belt.Result.Ok(x));
          
           type codec;

          [@bs.send] external encode : (codec, t, justNull, justNull) => byteBuffer = "";
          [@bs.send] external decode : (codec, Node.buffer, justNull, justNull) => t = "";

          [@bs.get] external codec : grpcProtoHandle => codec = "PdfResponse";

          let codec = myProtoHandle |. codec;

          let encode = x =>
            encode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined)
            |. bufferOfByteBuffer;
          let decode = x =>
            decode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined);
        };
module PdfService = {
/* fileName = "undefined" */
/* moduleName = "Com.Paletten.Werk.Proto.Pdf.Service.PdfService" */

          module GetPdfRpc = {
            /* Rpc module */
            /** the input/request type of the GetPdf RPC */
            type inputType = paletten.werk.proto.pdf.service.PdfRequest.t;
            /** the output/reply type of the GetPdf RPC */
            type outputType = paletten.werk.proto.pdf.service.PdfResponse.t;
            /** the type of the object from which rpc implementations may
             * obtain request payload and metadata. an object of this type is
             * passed to your rpc implementation. */
            [@bs.deriving abstract]
            type call = { request: inputType };
            /** server implementation function type. request payload and
             * metadata can be obtained via the `call` argument furnished to
             * your rpc implementation. the second argument allows you to
             * furnish a reply, although three of its four arguments should be
             * unused. */
            type t = (
              call,
              (.
                justNull,
                outputType,
                justNull,
                justNull
              ) => unit
            ) => unit;
            let getMeta : call => Js.Dict.t(Js.Json.t) = [%bs.raw {|
              call => call.metadata.getMap()
            |}];
          };
        
        /** objects of this type are actually grpc service client constructor
         * functions, however, they have a property, "service," whose value is
         * used to add services to a server object, too. */
        type grpcServiceObject;
        [@bs.get]
        external myServiceClient
          : grpcProtoHandle => grpcServiceObject
          = "PdfService";
        let myServiceClient = myProtoHandle |> myServiceClient;
        module Client = {
          /** a client object for the PdfService service */
          type t;
          /** the type of the error argument in the callback you supply when
           you invoke an rpc */
          type maybeError = Js.Nullable.t(grpcClientRpcInvokeError);
          /* client construction */
          let makeClient : (grpcServiceObject, string, channelCredentials) => t = [%bs.raw "(x,y,z) => new x(y,z)"];
          /** construct a client for the undefined.Com.Paletten.Werk.Proto.Pdf.Service.PdfService grpc service. arguments:
           serverAddress: string of address and port of server (e.g. "127.0.0.1:12345")
           chanCreds: your channel credentials */
          let makeClient = (serverAddress, chanCreds) => makeClient(myServiceClient, serverAddress, chanCreds);
      
          module GetPdfRpc = {
            /** the type of the callback you must supply when you invoke an rpc */
            type callback = (maybeError, GetPdfRpc.outputType) => unit;
            /** invoke an rpc using callback style. arguments:
             t: the client over which to send the rpc request
             GetPdfRpc.inputType: the request payload message
             callback: a function which will be invoked when a reply from the
               server is available, or when an error occurs */
            [@bs.send]
            external invoke : (t, GetPdfRpc.inputType, callback) => unit = "getPdf";
            /** invoke an rpc using futures */
            let invokeFuture = (client, input) => Future.make(resolve => invoke(client, input, (err, res) => {
              /* note: isNullable means "is nullish" */
              if (err |. Js.Nullable.isNullable) {
                /* no error */
                resolve(Belt.Result.Ok(res))
              } else {
                /* error */
                resolve(Belt.Result.Error(err))
              }
            }));
            /** invoke an rpc using promises */
            let invokePromise = (client, input) => Js.Promise.make((~resolve, ~reject) => {
              invoke(client, input, (err, res) => {
                switch (err |. Js.Nullable.toOption) {
                | Some(err) => reject(. GrpcClientRpcInvokeError(err))
                | None => resolve(. res)
                }
              });
            });
          }
        
        };
        type grpcServiceServer;
        [@bs.get]
        external getServerServiceHandle : grpcServiceObject => grpcServiceServer =
          "service";
        let myServerServiceHandle = myServiceClient |> getServerServiceHandle;
      /* Service implementation type */
[@bs.deriving abstract]
type t = {
getPdf: GetPdfRpc.t,
};
        [@bs.send] external addService : (server, grpcServiceServer, t) => unit = "";
        let addService = (server, t) =>
          addService(server, myServerServiceHandle, t);
        /** creates an implementation of the PdfService. The RPC
         * implementations you pass to this function will only be invoked after
         * any sanitization/validation/normalization code has processed the
         * message without error. */
        let make = (
      ~getPdf,
~getPdfErrorHandler,

) => t(

                ~getPdf=
          (call, callback) => {
            let request = call |. GetPdfRpc.requestGet;
            paletten.werk.proto.pdf.service.PdfRequest.validate(request)
            |. Future.get(x => {
                 switch (x) {
                 | Ok(request) => getPdf(call, request, callback)
                 | Error(errMsg) =>
                   errMsg |. getPdfErrorHandler |> reply(callback)
                 };
               });
          },
        )
};
};

  module Server = {
    module Credentials = {
      /* These are the public static constructor functions for
       * grpc.ServerCredentials
       */
      module Ssl = {
        [@bs.module "bs-grpc"]
        [@bs.scope "ServerCredentials"]
        external make : (buffer, array(ServerKeyAndCert.t), bool) => serverCredentials =
          "createSsl";
        let make = (~rootCert: buffer, ~privateKey: buffer, ~certChain: buffer) =>
          make(
            rootCert,
            [|ServerKeyAndCert.t(~privateKey, ~certChain)|],
            true,
          );
      };
      module Insecure = {
        [@bs.module "bs-grpc"]
        [@bs.scope "ServerCredentials"]
        external make : unit => serverCredentials = "createInsecure";
      };
    };

    [@bs.module "bs-grpc"][@bs.new]
    external newServer : unit => server = "Server";

    [@bs.send]
    external serverBind : (server, string, serverCredentials) => unit = "bind";

    [@bs.send]
    external start : server => unit = "start";

    /** Convenience function to instantiate and configure a GRPC server */
    let make = (
      ~credentials,
      ~pdfService=?,

      host,
    ) => {
      let server = newServer();
      serverBind(server, host, credentials);
      pdfService
    |. optCall(
      ~f=Com.Paletten.Werk.Proto.Pdf.Service.PdfService.addService(server)
    );
    
      start(server);
      server;
    };
  };
  
  module Client = {
    module Metadata = {
      type t;
      [@bs.module "bs-grpc"] [@bs.new] external make : unit => t = "Metadata";
      [@bs.send] external set : (t, string, string) => unit = "";
      let set = (t, key, value) => {
        set(t, key, value);
        t
      };
      module Generator = {
        /** the type of the function you must call to furnish an RPC invocation with
         either its metadata or a metadata generation error. see `makeGenerator`
        for details */
        type complete = (Js.Nullable.t(exn), t) => unit;
        /** consumers of bs-grpc who want to use metadata must implement a function
         of this type. see `makeGenerator` for more details */
        type generatorImplementation = (unit, complete) => unit;
        /** to populate a grpc request with metadata, grpc-node requires you to
         supply a metadata generator function, which receives as its first argument
         the call object reflecting the request payload (not available in this
         binding) while the second argument is a function your metadata generator
         function must invoke with either an exception or the resulting metadata */
        [@bs.module "bs-grpc"]
        [@bs.scope "credentials"]
        external make : generatorImplementation => callCredentials =
          "createFromMetadataGenerator";
      };
    };

    module Credentials = {
      [@bs.module "bs-grpc"]
      [@bs.scope "credentials"]
      external createInsecure : unit => channelCredentials = "";

      [@bs.module "bs-grpc"]
      [@bs.scope "credentials"]
      external createSsl : (buffer, buffer, buffer) => channelCredentials = "";

      [@bs.module "bs-grpc"]
      [@bs.scope "credentials"]
      external combine
        : (channelCredentials, callCredentials)
        => channelCredentials
        = "combineChannelCredentials";

      [@bs.module "bs-grpc"]
      [@bs.scope "credentials"]
      external combine3
        : (channelCredentials, callCredentials, callCredentials)
        => channelCredentials
        = "combineChannelCredentials";
    }
  };

  /* use this to load a nodejs Buffer object containing a base64-encoded
   * PEM format key/certificate
   */
  [@bs.val] [@bs.module "fs"]
  external loadCert : string => buffer = "readFileSync";
