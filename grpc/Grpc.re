/* AUTO-GENERATED BY bs-grpc --- EDIT AT YOUR OWN PERIL */

exception BsGrpcDecoderError(string);
exception ImpossibleError(string);
let (<<) = (f, g, x) => f(g(x));
/** an opaque type for error objects from grpc-node when the client invokes
   an RPC */
type grpcClientRpcInvokeError;
/* simply wraps grpcClientRpcInvokeError when an exception is needed */
exception GrpcClientRpcInvokeError(grpcClientRpcInvokeError);

/* "channel credentials" seem to be needed for creating a client */
type channelCredentials;
type callCredentials;
type serverCredentials;

/* protobufjs uses ByteBuffer abstraction over Node Buffer */
type byteBuffer;
[@bs.send] external bufferOfByteBuffer: byteBuffer => Node.buffer = "toBuffer";

/* flatMap an array of Futures */
let futureFlatMapArray =
    (f: 'a => Future.t('b), maxConcurrent, xs: array('a)) =>
  Future.(
    make(resolve => {
      let result: array(option('b)) =
        xs->Array.length->(Belt.Array.make(None));
      let xlen = Array.length(xs);
      let numJobs = ref(0);
      let cursor = ref(0);
      let rec pump = () => {
        if (cursor^ == xlen) {
          if (numJobs^ == 0) {
            (result |> Array.map(Belt.Option.getExn))->resolve;
          };
        } else {
          let i = cursor^;
          cursor := cursor^ + 1;
          numJobs := numJobs^ + 1;
          xs[i]
          ->f
          ->(
              get(x => {
                result[i] = Some(x);
                numJobs := numJobs^ - 1;
                pump();
              })
            );
        };
        ();
      };
      for (_ in 1 to min(maxConcurrent, xlen)) {
        pump();
      };
      ();
    })
  );

/** return Some(x) for the first x of an array for which predictate f
   returns true, starting from element at index n, or None if no such element is
   found */
let rec arrayFirst = (f, n, a) =>
  n < Array.length(a) ?
    f(a[n]) ? Some(a[n]) : arrayFirst(f, n + 1, a) : None;

/* utility eunction; TODO is there a stdlib answer? */
let optCall = (x, ~f) =>
  switch (x) {
  | None => ()
  | Some(x) => f(x)
  };

/** Convenience function for simplifying server replies */
let reply = (callback, x) =>
  callback(.
    Js.Nullable.null,
    x,
    Js.Nullable.undefined,
    Js.Nullable.undefined,
  );

module Validation = {
  exception MissingFieldError;
  exception StringTooLongError;
  exception StringTooShortError;
  exception ArrayTooShortError;
  exception FractionalNumberError;
  exception WrongStringError;
  exception UnimplementedError;
  exception WrongNumberError;
  exception NumberOutOfRangeError;
  exception NumberNotPositiveError;
  exception RegexMatchError;
  exception TransFieldError(string);

  /* invokes user-supplied function to perform multi-field
   * validation, if such a function is supplied
   * TODO move to Validation module */
  let transFieldError = errMsg => Belt.Result.Error(TransFieldError(errMsg));

  type field('a) =
    | Field(string, Future.t(Belt.Result.t(option('a), exn)));
  let fieldMap = (f, Field(fieldName, x)) => Field(fieldName, f(x));
  let fieldGet = (Field(_, x)) => x;
  let futureMap = (a, b) => Future.map(b, a);
  let futureFlatMap = (a, b) => Future.map(b, a);
  let resultMap = (a, b) => Belt.Result.map(b, a);
  let resultFlatMap = (a, b) => Belt.Result.flatMap(b, a);
  let optionMap = (a, b) => Belt.Option.map(b, a);
  let optionFlatMap = (a, b) => Belt.Option.flatMap(b, a);
  let resultOptionFlatMap = f =>
    fun
    | Belt.Result.Ok(Some(x)) => f(x)
    | x => x;

  let okSome = x => Belt.Result.Ok(Some(x));
  let error = e => Belt.Result.Error(e);

  let value = (fieldName, x) =>
    Field(fieldName, Future.value(Belt.Result.Ok(x)));
  let fieldValidatorOfMessageValidator = (f, Field(name, future)) =>
    future
    ->(
        Future.flatMapOk(x =>
          switch (x) {
          | None => None->Belt.Result.Ok->Future.value
          | Some(thing) =>
            f(thing)
            ->(Future.mapError(str => str->TransFieldError))
            ->(Future.mapOk(x => Some(x)))
          }
        )
      )
    ->(fresult => Field(name, fresult));

  let numberRange = (lo, hi) =>
    fieldMap @@
    futureMap @@
    resultOptionFlatMap @@
    (x => lo <= x && x <= hi ? okSome(x) : error(NumberOutOfRangeError));
  let maxNumber = numberRange(Js.Int.min);
  let minNumber = n => numberRange(n, Js.Int.max);
  /* TODO can isEqualNumber and isEqualString be merged? */
  let isEqualNumber = n =>
    fieldMap @@
    futureMap @@
    resultOptionFlatMap @@
    (x => x == n ? okSome(x) : error(WrongNumberError));
  let isEqualString = s =>
    fieldMap @@
    futureMap @@
    resultOptionFlatMap @@
    (x => x == s ? okSome(x) : error(WrongStringError));
  let isInt =
    fieldMap @@
    futureMap @@
    resultOptionFlatMap @@
    (x => Js.Math.trunc(x) == x ? okSome(x) : error(FractionalNumberError));
  /* TODO can notEqualNumber and notEqualString be merged? */
  let notEqualNumber = n =>
    fieldMap @@
    futureMap @@
    resultOptionFlatMap @@
    (x => x != n ? okSome(x) : error(WrongNumberError));
  let notEqualString = s =>
    fieldMap @@
    futureMap @@
    resultOptionFlatMap @@
    (x => s == x ? okSome(x) : error(WrongStringError));
  /* TODO is this in the stdlib? */
  [@bs.new] external newRegExp: string => Js.Re.t = "RegExp";
  let matchRegex = re => {
    let re = newRegExp(re);
    fieldMap @@
    futureMap @@
    resultOptionFlatMap @@
    (x => x->(Js.Re.test(re)) ? okSome(x) : error(RegexMatchError));
  };
  let required = x =>
    x
    |> fieldMap @@
    futureMap(
      fun
      | Belt.Result.Ok(None) => error(MissingFieldError)
      | x => x,
    );
  let maxStrLen = len =>
    fieldMap @@
    futureMap @@
    resultOptionFlatMap @@
    (x => x->String.length <= len ? okSome(x) : error(StringTooLongError));
  let minStrLen = len =>
    fieldMap @@
    futureMap @@
    resultOptionFlatMap @@
    (x => x->String.length >= len ? okSome(x) : error(StringTooShortError));
  let nonEmptyString = minStrLen(1);
  let trimString =
    fieldMap @@ futureMap @@ resultMap @@ optionMap @@ Js.String.trim;

  /* TODO implement in terms of previous validators */
  let positive = minNumber(1);
  /* Is US Employer Identification Numebr? */
  /* let isUSEIN */
  let repeated:
    (field('a) => field('a), field(array('a))) => field(array('a)) =
    (f, Field(fieldName, future)) => {
      let foo = x =>
        switch (x) {
        | None => None->Belt.Result.Ok->Future.value
        | Some(thing) =>
          let bar =
            thing
            |> futureFlatMapArray(
                 x =>
                   (
                     Field(fieldName, Future.value(Belt.Result.Ok(Some(x))))
                     |> f
                     |> fieldGet
                   )
                   ->(Future.mapOk(Belt.Option.getExn)),
                 0x7fffffff,
               );

          bar
          ->(
              Future.map((x: array(Belt.Result.t('a, exn))) => {
                let firstError = arrayFirst(Belt.Result.isError, 0, x);
                switch (firstError) {
                | Some(Belt.Result.Error(x)) => Belt.Result.Error(x)
                | None => Belt.Result.Ok(Array.map(Belt.Result.getExn, x))
                | Some(Belt.Result.Ok(_)) =>
                  raise(ImpossibleError("found unfound element"))
                };
              })
            )
          ->(Future.mapOk(x => Some(x)));
        };
      let future = Future.flatMapOk(future, foo);
      Field(fieldName, future);
    };

  let minItemCount = (len, x: field(array('a))) =>
    x
    |> fieldMap @@
    futureMap(
      fun
      | Belt.Result.Ok(Some(x)) =>
        x->Array.length < len ?
          Belt.Result.Error(ArrayTooShortError) : Belt.Result.Ok(Some(x))
      | x => x,
    );
  let maxItemCount = (len, x: field(array('a))) =>
    x
    |> fieldMap @@
    futureMap(
      fun
      | Belt.Result.Ok(Some(x)) =>
        x->Array.length > len ?
          Belt.Result.Error(ArrayTooShortError) : Belt.Result.Ok(Some(x))
      | x => x,
    );

  let err2msg =
    fun
    | MissingFieldError => "required field missing"
    | StringTooLongError => "string value too long"
    | StringTooShortError => "string value too short"
    | NumberNotPositiveError => "number value non-positive"
    | ArrayTooShortError => "not enough items"
    | FractionalNumberError => "number is fractional"
    | WrongStringError => "string mismatch"
    | UnimplementedError => "unimplemented validation"
    | WrongNumberError => "wrong number"
    | NumberOutOfRangeError => "number ouf ot range"
    | RegexMatchError => "string pattern mismatch"
    | TransFieldError(s) => "involving multiple fields: " ++ s
    | _ => "unknown error";

  let fold = (Field(fieldName, Future.Future(get)), happy, sad) =>
    get(x =>
      switch (x) {
      | Belt.Result.Ok(x) => happy(x)
      | Belt.Result.Error(err) => err |> err2msg |> sad(fieldName)
      }
    );
};

/** a type that cannot be instantiated */
type uninstantiable;
/** a type to only hold values like Js.Nullable.null and
   * Js.Nullable.undefined */
type justNull = Js.Nullable.t(uninstantiable);
type grpcLoadResult;

[@bs.module "bs-grpc"]
external grpcLoadProto: string => grpcLoadResult = "load";

/* Represents a grpc.Server object */
type server;

/* A node.js bufffer TODO see if there is a more standard type somewhere
 * for this. We treat it as opaque, though, so it's probably okay.
 */
type buffer;

/* This type is part of the type of grpc.ServerCredentials.createSsl() */
module ServerKeyAndCert = {
  [@bs.deriving abstract]
  type t = {
    [@bs.as "private_key"]
    privateKey: buffer,
    [@bs.as "cert_chain"]
    certChain: buffer,
  };
};
/* fileName = "undefined" */
/* moduleName = "*root*" */
module Chat = {
  /* fileName = "chat.proto" */
  /* moduleName = "Chat" */

  type grpcProtoHandle;
  [@bs.get]
  external getProtoHandle: grpcLoadResult => grpcProtoHandle = "chat";
  let myProtoHandle = grpcLoadProto("chat.proto") |> getProtoHandle;
  module MessageReply = {
    /* fileName = "undefined" */
    /* moduleName = "Chat.MessageReply" */
    /* Message module */
    [@bs.deriving abstract]
    type t = {
      [@bs.optional]
      error: string,
    };
    /* safe message constructor (may replace t()) */
    let make = (~error=?, ()) => t(~error?, ());

    /* no validation specified for this message */
    let validate = x => Future.value(Belt.Result.Ok(x));

    [@bs.deriving abstract]
    type codec = {
      encode: (t, justNull, justNull) => byteBuffer,
      decode: (Node.buffer, justNull, justNull) => t,
    };

    [@bs.get] external codec: grpcProtoHandle => codec = "MessageReply";

    let codec = myProtoHandle->codec;

    let encode = codec->encodeGet;
    let decode = codec->decodeGet;

    let encode = x =>
      x
      ->(encode(Js.Nullable.undefined, Js.Nullable.undefined))
      ->bufferOfByteBuffer;
    let decode = x =>
      x->(decode(Js.Nullable.undefined, Js.Nullable.undefined));
  };
  module Urgency = {
    /* fileName = "undefined" */
    /* moduleName = "Chat.Urgency" */

    /* enum type */
    type t =
      | UrgencyNormal
      | UrgencyUrgent
      | UrgencyRelaxed;

    /** convert a grpc enum ordinal to its Urgency.t counterpart; internal */
    let urgencyOfInt =
      fun
      | 0 => UrgencyNormal
      | 1 => UrgencyUrgent
      | 2 => UrgencyRelaxed

      | x =>
        raise(
          BsGrpcDecoderError(
            {j|bs-grpc encountered invalid Urgency enum value $x|j},
          ),
        );
    /** convert a Urgency.t to its the grpc enum ordinal counterpart; internal */
    let intOfUrgency =
      fun
      | UrgencyNormal => 0
      | UrgencyUrgent => 1
      | UrgencyRelaxed => 2;
  };
  module MessageRequest = {
    /* fileName = "undefined" */
    /* moduleName = "Chat.MessageRequest" */
    /* Message module */
    [@bs.deriving abstract]
    type t = {
      [@bs.optional]
      channel: string,
      [@bs.optional]
      text: string,
      [@bs.optional]
      urgency: int,
    };
    /** message constructor (shadows the deriving abstract constructor) */
    let t = (~channel=?, ~text=?, ~urgency=?, ()) =>
      t(
        ~channel?,
        ~text?,
        ~urgency=?(Validation.optionMap @@ Urgency.intOfUrgency) @@ urgency,
        (),
      );
    /* enum converting getter */
    let urgencyGet =
      Validation.optionMap @@ Urgency.urgencyOfInt << urgencyGet;
    /* safe message constructor (may replace t()) */
    let make = (~channel=?, ~text=?, ~urgency=?, ()) =>
      t(~channel?, ~text?, ~urgency?, ());

    /* no validation specified for this message */
    let validate = x => Future.value(Belt.Result.Ok(x));

    [@bs.deriving abstract]
    type codec = {
      encode: (t, justNull, justNull) => byteBuffer,
      decode: (Node.buffer, justNull, justNull) => t,
    };

    [@bs.get] external codec: grpcProtoHandle => codec = "MessageRequest";

    let codec = myProtoHandle->codec;

    let encode = codec->encodeGet;
    let decode = codec->decodeGet;

    let encode = x =>
      x
      ->(encode(Js.Nullable.undefined, Js.Nullable.undefined))
      ->bufferOfByteBuffer;
    let decode = x =>
      x->(decode(Js.Nullable.undefined, Js.Nullable.undefined));
  };
  module ChatService = {
    /* fileName = "undefined" */
    /* moduleName = "Chat.ChatService" */

    module SendMessageRpc = {
      /* Rpc module */
      /** the input/request type of the SendMessage RPC */
      type inputType = MessageRequest.t;
      /** the output/reply type of the SendMessage RPC */
      type outputType = MessageReply.t;
      /** the type of the object from which rpc implementations may
             * obtain request payload and metadata. an object of this type is
             * passed to your rpc implementation. */
      [@bs.deriving abstract]
      type call = {request: inputType};
      /** server implementation function type. request payload and
             * metadata can be obtained via the `call` argument furnished to
             * your rpc implementation. the second argument allows you to
             * furnish a reply, although three of its four arguments should be
             * unused. */
      type t =
        (call, (. justNull, outputType, justNull, justNull) => unit) => unit;
      let getMeta: call => Js.Dict.t(Js.Json.t) = [%bs.raw
        {|
              call => call.metadata.getMap()
            |}
      ];
    };

    /** objects of this type are actually grpc service client constructor
         * functions, however, they have a property, "service," whose value is
         * used to add services to a server object, too. */
    type grpcServiceObject;
    [@bs.get]
    external myServiceClient: grpcProtoHandle => grpcServiceObject =
      "ChatService";
    let myServiceClient = myProtoHandle |> myServiceClient;
    module Client = {
      /** a client object for the ChatService service */
      type t;
      /** the type of the error argument in the callback you supply when
           you invoke an rpc */
      type maybeError = Js.Nullable.t(grpcClientRpcInvokeError);
      /* client construction */
      let makeClient: (grpcServiceObject, string, channelCredentials) => t = [%bs.raw
        "(x,y,z) => new x(y,z)"
      ];
      /** construct a client for the undefined.Chat.ChatService grpc service. arguments:
           serverAddress: string of address and port of server (e.g. "127.0.0.1:12345")
           chanCreds: your channel credentials */
      let makeClient = (serverAddress, chanCreds) =>
        makeClient(myServiceClient, serverAddress, chanCreds);

      module SendMessageRpc = {
        /** the type of the callback you must supply when you invoke an rpc */
        type callback = (maybeError, SendMessageRpc.outputType) => unit;
        /** invoke an rpc using callback style. arguments:
             t: the client over which to send the rpc request
             SendMessageRpc.inputType: the request payload message
             callback: a function which will be invoked when a reply from the
               server is available, or when an error occurs */
        [@bs.send]
        external invoke: (t, SendMessageRpc.inputType, callback) => unit =
          "sendMessage";
        /** invoke an rpc using futures */
        let invokeFuture = (client, input) =>
          Future.make(resolve =>
            invoke(client, input, (err, res) =>
              /* note: isNullable means "is nullish" */
              if (err->Js.Nullable.isNullable) {
                /* no error */
                resolve(Belt.Result.Ok(res));
              } else {
                /* error */
                resolve(Belt.Result.Error(err));
              }
            )
          );
        /** invoke an rpc using promises */
        let invokePromise = (client, input) =>
          Js.Promise.make((~resolve, ~reject) =>
            invoke(client, input, (err, res) =>
              switch (err->Js.Nullable.toOption) {
              | Some(err) => reject(. GrpcClientRpcInvokeError(err))
              | None => resolve(. res)
              }
            )
          );
      };
    };
    type grpcServiceServer;
    [@bs.get]
    external getServerServiceHandle: grpcServiceObject => grpcServiceServer =
      "service";
    let myServerServiceHandle = myServiceClient |> getServerServiceHandle;
    /* Service implementation type */
    [@bs.deriving abstract]
    type t = {sendMessage: SendMessageRpc.t};
    [@bs.send]
    external addService: (server, grpcServiceServer, t) => unit = "";
    let addService = (server, t) =>
      addService(server, myServerServiceHandle, t);
    /** creates an implementation of the ChatService. The RPC
         * implementations you pass to this function will only be invoked after
         * any sanitization/validation/normalization code has processed the
         * message without error. */
    let make = (~sendMessage, ~sendMessageErrorHandler) =>
      t(~sendMessage=(call, callback) => {
        let request = call->SendMessageRpc.requestGet;
        MessageRequest.validate(request)
        ->(
            Future.get(x =>
              switch (x) {
              | Ok(request) => sendMessage(call, request, callback)
              | Error(errMsg) =>
                errMsg->sendMessageErrorHandler |> reply(callback)
              }
            )
          );
      });
  };
};

module Server = {
  module Credentials = {
    /* These are the public static constructor functions for
     * grpc.ServerCredentials
     */
    module Ssl = {
      [@bs.module "bs-grpc"] [@bs.scope "ServerCredentials"]
      external make:
        (buffer, array(ServerKeyAndCert.t), bool) => serverCredentials =
        "createSsl";
      let make = (~rootCert: buffer, ~privateKey: buffer, ~certChain: buffer) =>
        make(
          rootCert,
          [|ServerKeyAndCert.t(~privateKey, ~certChain)|],
          true,
        );
    };
    module Insecure = {
      [@bs.module "bs-grpc"] [@bs.scope "ServerCredentials"]
      external make: unit => serverCredentials = "createInsecure";
    };
  };

  [@bs.module "bs-grpc"] [@bs.new]
  external newServer: unit => server = "Server";

  [@bs.send]
  external serverBind: (server, string, serverCredentials) => unit = "bind";

  [@bs.send] external start: server => unit = "start";

  /** Convenience function to instantiate and configure a GRPC server */
  let make = (~credentials, ~chatService=?, host) => {
    let server = newServer();
    serverBind(server, host, credentials);
    chatService->(optCall(~f=Chat.ChatService.addService(server)));

    start(server);
    server;
  };
};

module Client = {
  module Metadata = {
    type t;
    [@bs.module "bs-grpc"] [@bs.new] external make: unit => t = "Metadata";
    [@bs.send] external set: (t, string, string) => unit = "";
    let set = (t, key, value) => {
      set(t, key, value);
      t;
    };
    module Generator = {
      /** the type of the function you must call to furnish an RPC invocation with
         either its metadata or a metadata generation error. see `makeGenerator`
        for details */
      type complete = (Js.Nullable.t(exn), t) => unit;
      /** consumers of bs-grpc who want to use metadata must implement a function
         of this type. see `makeGenerator` for more details */
      type generatorImplementation = (unit, complete) => unit;
      /** to populate a grpc request with metadata, grpc-node requires you to
         supply a metadata generator function, which receives as its first argument
         the call object reflecting the request payload (not available in this
         binding) while the second argument is a function your metadata generator
         function must invoke with either an exception or the resulting metadata */
      [@bs.module "bs-grpc"] [@bs.scope "credentials"]
      external make: generatorImplementation => callCredentials =
        "createFromMetadataGenerator";
    };
  };

  module Credentials = {
    [@bs.module "bs-grpc"] [@bs.scope "credentials"]
    external createInsecure: unit => channelCredentials = "";

    [@bs.module "bs-grpc"] [@bs.scope "credentials"]
    external createSsl: (buffer, buffer, buffer) => channelCredentials = "";

    [@bs.module "bs-grpc"] [@bs.scope "credentials"]
    external combine:
      (channelCredentials, callCredentials) => channelCredentials =
      "combineChannelCredentials";

    [@bs.module "bs-grpc"] [@bs.scope "credentials"]
    external combine3:
      (channelCredentials, callCredentials, callCredentials) =>
      channelCredentials =
      "combineChannelCredentials";
  };
};

/* use this to load a nodejs Buffer object containing a base64-encoded
 * PEM format key/certificate
 */
[@bs.val] [@bs.module "fs"]
external loadCert: string => buffer = "readFileSync";
